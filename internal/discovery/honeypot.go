package discovery

import (
	"regexp"
	"strings"
)

// HoneypotDetector analyzes proxy candidates for honeypot indicators
type HoneypotDetector struct {
	// Suspicious content patterns
	suspiciousPatterns []SuspiciousPattern
	
	// Honeypot indicators by category
	htmlIndicators     []string
	contactIndicators  []string
	styleIndicators    []string
	legalIndicators    []string
	serverIndicators   []string
}

// SuspiciousPattern represents a pattern that indicates honeypot behavior
type SuspiciousPattern struct {
	Pattern     *regexp.Regexp
	Description string
	Weight      float64 // Suspicion weight (0.0-1.0)
	Category    string
}

// HoneypotAnalysis contains the results of honeypot detection
type HoneypotAnalysis struct {
	IsHoneypot       bool                    `json:"is_honeypot"`
	SuspicionScore   float64                 `json:"suspicion_score"`   // 0.0-1.0
	Indicators       []HoneypotIndicator     `json:"indicators"`
	ReasonSummary    string                  `json:"reason_summary"`
	Recommendation   string                  `json:"recommendation"`
}

// HoneypotIndicator represents a specific honeypot indicator found
type HoneypotIndicator struct {
	Type        string  `json:"type"`
	Description string  `json:"description"`
	Evidence    string  `json:"evidence"`
	Weight      float64 `json:"weight"`
}

// NewHoneypotDetector creates a new honeypot detector with predefined patterns
func NewHoneypotDetector() *HoneypotDetector {
	detector := &HoneypotDetector{
		htmlIndicators: []string{
			"<!DOCTYPE html",
			"<html>",
			"<head>",
			"<style",
			"<link rel=\"stylesheet\"",
			"<meta name=\"",
			"<title>ERROR",
			"<title>Access Denied",
			"<body id=",
			"<div id=\"",
		},
		
		contactIndicators: []string{
			"webmaster",
			"administrator",
			"cache administrator",
			"system administrator",
			"mailto:",
			"contact us",
			"support@",
			"admin@",
		},
		
		styleIndicators: []string{
			"font-family:",
			"background:",
			"color:",
			"margin:",
			"padding:",
			".css",
			"stylesheet",
			"/* ",
			"*/",
		},
		
		legalIndicators: []string{
			"Copyright",
			"All rights reserved",
			"Licensed under",
			"This software is",
			"Foundation and contributors",
			"GNU General Public License",
			"Creative Commons",
			"Free Software Foundation",
		},
		
		serverIndicators: []string{
			"Generated by",
			"Powered by",
			"Server:",
			"X-Powered-By:",
			"Version:",
			"Build:",
		},
	}

	// Initialize regex patterns
	detector.suspiciousPatterns = []SuspiciousPattern{
		// Elaborate error pages
		{
			Pattern:     regexp.MustCompile(`(?i)<style.*?</style>`),
			Description: "Contains elaborate CSS styling",
			Weight:      0.8,
			Category:    "presentation",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)webmaster.*?mailto:`),
			Description: "Contains webmaster contact link",
			Weight:      0.9,
			Category:    "contact",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)cache administrator.*?href="mailto:`),
			Description: "Contains cache administrator email",
			Weight:      0.9,
			Category:    "contact",
		},
		
		// Legal and copyright notices
		{
			Pattern:     regexp.MustCompile(`(?i)Copyright.*?\d{4}.*?Foundation`),
			Description: "Contains detailed copyright notice",
			Weight:      0.7,
			Category:    "legal",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)Licensed under.*?GPL`),
			Description: "Contains software license information",
			Weight:      0.6,
			Category:    "legal",
		},
		
		// Detailed error explanations
		{
			Pattern:     regexp.MustCompile(`(?i)Some possible problems are:`),
			Description: "Provides detailed troubleshooting help",
			Weight:      0.8,
			Category:    "help",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)The following error was encountered`),
			Description: "Formal error explanation",
			Weight:      0.7,
			Category:    "help",
		},
		
		// Honeypot-specific indicators
		{
			Pattern:     regexp.MustCompile(`(?i)squid.*?proxy.*?error`),
			Description: "Squid proxy error page template",
			Weight:      0.6,
			Category:    "template",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)ERR_[A-Z_]+`),
			Description: "Structured error codes",
			Weight:      0.5,
			Category:    "template",
		},
		
		// Suspicious timing and details
		{
			Pattern:     regexp.MustCompile(`(?i)Generated.*?\d{4}.*?GMT`),
			Description: "Contains precise generation timestamp",
			Weight:      0.4,
			Category:    "metadata",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)ClientIP.*?\d+\.\d+\.\d+\.\d+`),
			Description: "Logs client IP address",
			Weight:      0.8,
			Category:    "logging",
		},
		
		// Tracking and monitoring
		{
			Pattern:     regexp.MustCompile(`(?i)subject=.*?body=.*?TimeStamp`),
			Description: "Pre-filled email with tracking data",
			Weight:      0.9,
			Category:    "tracking",
		},
		{
			Pattern:     regexp.MustCompile(`(?i)HTTP Request:.*?ClientIP:`),
			Description: "Detailed request logging",
			Weight:      0.8,
			Category:    "logging",
		},
	}

	return detector
}

// AnalyzeCandidate performs honeypot analysis on a proxy candidate
func (hd *HoneypotDetector) AnalyzeCandidate(candidate *ProxyCandidate) *HoneypotAnalysis {
	analysis := &HoneypotAnalysis{
		IsHoneypot:     false,
		SuspicionScore: 0.0,
		Indicators:     make([]HoneypotIndicator, 0),
		Recommendation: "SAFE - No honeypot indicators detected",
	}

	// Analyze various data sources
	content := hd.extractAnalyzableContent(candidate)
	if content == "" {
		return analysis // No content to analyze
	}

	// Check for suspicious patterns
	for _, pattern := range hd.suspiciousPatterns {
		if matches := pattern.Pattern.FindAllString(content, -1); len(matches) > 0 {
			indicator := HoneypotIndicator{
				Type:        pattern.Category,
				Description: pattern.Description,
				Evidence:    hd.truncateEvidence(matches[0]),
				Weight:      pattern.Weight,
			}
			analysis.Indicators = append(analysis.Indicators, indicator)
			analysis.SuspicionScore += pattern.Weight
		}
	}

	// Check for simple keyword indicators
	analysis.SuspicionScore += hd.analyzeKeywordIndicators(content, analysis)

	// Normalize suspicion score (prevent overflow)
	if analysis.SuspicionScore > 1.0 {
		analysis.SuspicionScore = 1.0
	}

	// Determine if this is likely a honeypot
	if analysis.SuspicionScore >= 0.7 {
		analysis.IsHoneypot = true
		analysis.Recommendation = "AVOID - High probability honeypot/monitoring system"
	} else if analysis.SuspicionScore >= 0.4 {
		analysis.IsHoneypot = false
		analysis.Recommendation = "CAUTION - Some suspicious indicators detected"
	}

	// Generate reason summary
	analysis.ReasonSummary = hd.generateReasonSummary(analysis)

	return analysis
}

// extractAnalyzableContent extracts content from various candidate fields
func (hd *HoneypotDetector) extractAnalyzableContent(candidate *ProxyCandidate) string {
	var content strings.Builder

	// Extract HTML content from headers
	if candidate.Headers != nil {
		for key, value := range candidate.Headers {
			content.WriteString(key + ": " + value + "\n")
		}
	}

	// Add server header
	if candidate.ServerHeader != "" {
		content.WriteString("Server: " + candidate.ServerHeader + "\n")
	}

	return content.String()
}

// analyzeKeywordIndicators checks for simple keyword-based indicators
func (hd *HoneypotDetector) analyzeKeywordIndicators(content string, analysis *HoneypotAnalysis) float64 {
	contentLower := strings.ToLower(content)
	suspicionBoost := 0.0

	// HTML presentation indicators
	htmlCount := 0
	for _, indicator := range hd.htmlIndicators {
		if strings.Contains(contentLower, strings.ToLower(indicator)) {
			htmlCount++
		}
	}
	if htmlCount >= 3 {
		analysis.Indicators = append(analysis.Indicators, HoneypotIndicator{
			Type:        "presentation",
			Description: "Contains multiple HTML elements",
			Evidence:    "Multiple HTML tags detected",
			Weight:      0.3,
		})
		suspicionBoost += 0.3
	}

	// Contact information indicators
	contactCount := 0
	for _, indicator := range hd.contactIndicators {
		if strings.Contains(contentLower, strings.ToLower(indicator)) {
			contactCount++
			analysis.Indicators = append(analysis.Indicators, HoneypotIndicator{
				Type:        "contact",
				Description: "Contains administrative contact information",
				Evidence:    indicator,
				Weight:      0.2,
			})
			suspicionBoost += 0.2
			break // Avoid duplicate indicators
		}
	}

	// Style indicators
	styleCount := 0
	for _, indicator := range hd.styleIndicators {
		if strings.Contains(contentLower, strings.ToLower(indicator)) {
			styleCount++
		}
	}
	if styleCount >= 3 {
		analysis.Indicators = append(analysis.Indicators, HoneypotIndicator{
			Type:        "presentation",
			Description: "Contains CSS styling elements",
			Evidence:    "Multiple CSS properties detected",
			Weight:      0.4,
		})
		suspicionBoost += 0.4
	}

	// Legal indicators
	for _, indicator := range hd.legalIndicators {
		if strings.Contains(contentLower, strings.ToLower(indicator)) {
			analysis.Indicators = append(analysis.Indicators, HoneypotIndicator{
				Type:        "legal",
				Description: "Contains legal/copyright information",
				Evidence:    indicator,
				Weight:      0.3,
			})
			suspicionBoost += 0.3
			break // Avoid duplicate indicators
		}
	}

	return suspicionBoost
}

// truncateEvidence truncates evidence to reasonable length
func (hd *HoneypotDetector) truncateEvidence(evidence string) string {
	const maxLen = 100
	if len(evidence) <= maxLen {
		return evidence
	}
	return evidence[:maxLen] + "..."
}

// generateReasonSummary creates a human-readable summary of findings
func (hd *HoneypotDetector) generateReasonSummary(analysis *HoneypotAnalysis) string {
	if len(analysis.Indicators) == 0 {
		return "No suspicious indicators found"
	}

	categories := make(map[string]int)
	for _, indicator := range analysis.Indicators {
		categories[indicator.Type]++
	}

	var reasons []string
	if categories["presentation"] > 0 {
		reasons = append(reasons, "elaborate HTML presentation")
	}
	if categories["contact"] > 0 {
		reasons = append(reasons, "administrative contact info")
	}
	if categories["legal"] > 0 {
		reasons = append(reasons, "legal/copyright notices")
	}
	if categories["help"] > 0 {
		reasons = append(reasons, "detailed error explanations")
	}
	if categories["tracking"] > 0 {
		reasons = append(reasons, "tracking/monitoring behavior")
	}
	if categories["logging"] > 0 {
		reasons = append(reasons, "detailed request logging")
	}

	if len(reasons) == 0 {
		return "Generic suspicious patterns detected"
	}

	if len(reasons) == 1 {
		return "Contains " + reasons[0]
	}

	last := reasons[len(reasons)-1]
	others := strings.Join(reasons[:len(reasons)-1], ", ")
	return "Contains " + others + " and " + last
}

// FilterHoneypots removes suspected honeypots from candidate list
func (hd *HoneypotDetector) FilterHoneypots(candidates []ProxyCandidate, threshold float64) ([]ProxyCandidate, []ProxyCandidate) {
	var clean []ProxyCandidate
	var suspicious []ProxyCandidate

	for _, candidate := range candidates {
		analysis := hd.AnalyzeCandidate(&candidate)
		
		// Add analysis to candidate metadata
		if candidate.ThreatTags == nil {
			candidate.ThreatTags = make([]string, 0)
		}
		
		if analysis.IsHoneypot {
			candidate.ThreatTags = append(candidate.ThreatTags, "suspected_honeypot")
			suspicious = append(suspicious, candidate)
		} else if analysis.SuspicionScore >= threshold {
			candidate.ThreatTags = append(candidate.ThreatTags, "suspicious")
			suspicious = append(suspicious, candidate)
		} else {
			clean = append(clean, candidate)
		}
	}

	return clean, suspicious
}

// UpdateCandidateConfidence adjusts candidate confidence based on honeypot analysis
func (hd *HoneypotDetector) UpdateCandidateConfidence(candidate *ProxyCandidate) {
	analysis := hd.AnalyzeCandidate(candidate)
	
	// Reduce confidence based on suspicion score
	confidencePenalty := analysis.SuspicionScore * 0.8 // Max 80% reduction
	candidate.Confidence = candidate.Confidence * (1.0 - confidencePenalty)
	
	// Ensure confidence doesn't go negative
	if candidate.Confidence < 0.0 {
		candidate.Confidence = 0.0
	}
}

// Common honeypot patterns observed in the wild
var CommonHoneypotPatterns = []string{
	// Squid proxy honeypots
	"Your cache administrator is",
	"The following error was encountered while trying to retrieve the URL",
	"Some aspect of the requested URL is incorrect",
	"Some possible problems are:",
	
	// Generic proxy honeypots  
	"Access Denied",
	"Proxy Error", 
	"Authentication Required",
	"Service Unavailable",
	
	// Monitoring indicators
	"Generated by",
	"Request ID:",
	"Client IP:",
	"Timestamp:",
	"Log ID:",
	
	// Legal/attribution honeypots
	"Copyright",
	"All rights reserved", 
	"Licensed under",
	"Terms of Service",
	"Privacy Policy",
}